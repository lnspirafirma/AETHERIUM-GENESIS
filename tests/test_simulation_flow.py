import pytest
import asyncio
from core.aether_conductor import conductor # Use the singleton
from agents.gep_enforcer import GEPPolicyEnforcer
from agents.agio_sage_agent import AgioSageAgent
from agents.analysis_agent import AnalysisAgent
from agents.resource_agent import ResourceAgent
from core.envelope import Envelope, AetherIntent
from core.signature import AISource

@pytest.mark.asyncio
async def test_full_simulation_flow(clean_conductor):
    """
    Simulates the flow described in main_simulation.py but using pytest mechanisms.
    Using 'clean_conductor' ensures we start with a fresh bus.
    """

    # 1. Initialize Agents
    gep = GEPPolicyEnforcer(clean_conductor)
    await gep.start()

    agio = AgioSageAgent(clean_conductor)
    await agio.start()

    resource = ResourceAgent(clean_conductor)
    await resource.start()

    analysis = AnalysisAgent(clean_conductor)
    # analysis doesn't have a start method that subscribes, it just publishes

    # Track executed tasks
    executed_tasks = []
    async def execution_tracker(envelope):
        executed_tasks.append(envelope.payload.get("tool_call"))

    # Spy on execution
    await clean_conductor.subscribe("aether.tasks.approved", execution_tracker)

    # --- TEST 1: Economic Transaction (Should be Approved) ---
    # Trigger
    await analysis.request_economic_transaction()

    # Wait for propagation (Analysis -> GEP -> AGIO -> GEP -> Approved -> Resource)
    await asyncio.sleep(0.5)

    assert "economic_transaction" in executed_tasks

    # --- TEST 2: High Risk Simulation (Should be Approved via simple check?) ---
    # In config: "generate_simulation_data" has "check_via_agio": False
    # So it should be auto-approved by GEP.

    await analysis.request_simulation_data()
    await asyncio.sleep(0.2)

    assert "generate_simulation_data" in executed_tasks

@pytest.mark.asyncio
async def test_blocked_flow(clean_conductor):
    """Test a flow that should be blocked by AGIO."""

    gep = GEPPolicyEnforcer(clean_conductor)
    await gep.start()

    agio = AgioSageAgent(clean_conductor)
    await agio.start()

    # Inject a malicious rule for testing purposes (Runtime modification)
    gep.rules["malicious_op"] = {
        "risk_level": "critical",
        "audit_gate_required": True,
        "check_via_agio": True,
        "agio_query_template": "Is this safe?"
    }

    executed_tasks = []
    async def execution_tracker(envelope):
        executed_tasks.append(envelope.payload.get("tool_call"))
    await clean_conductor.subscribe("aether.tasks.approved", execution_tracker)

    failed_tasks = []
    async def fail_tracker(envelope):
        failed_tasks.append(envelope.payload)
    await clean_conductor.subscribe("aether.tasks.failed", fail_tracker)

    # Publish malicious task
    await clean_conductor.publish("aether.tasks.pending", Envelope(
        intent=AetherIntent.REQUEST_ACTION,
        sender_id="hacker",
        payload={
            "tool_call": "malicious_op",
            "msg": "destroy",
            "_security_context": "Generated by AGIO-CODEX" # Pass conductor trust check
        } # "Is this safe?" query -> AGIO checks "Stability" -> fails
    ))

    await asyncio.sleep(0.5)

    assert "malicious_op" not in executed_tasks
    assert len(failed_tasks) == 1
    assert failed_tasks[0]["reason"] == "AGIO Denied"
